<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>LeetCode Algorithm Study Roadmap</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 20px;
      background-color: #f9f9f9;
      color: #333;
    }
    h1, h2 {
      color: #2c3e50;
    }
    ul {
      margin-top: 0;
    }
    section {
      margin-bottom: 30px;
    }
  </style>
</head>
<body>
  <h1>LeetCode Algorithm Study Roadmap</h1>

  <section>
    <h2>1. Data Structures</h2>
    <ul>
      <li>Arrays & Strings – Two-pointers, sliding window, substrings</li>
      <li>Linked Lists – Rotations, reversals, cycle detection</li>
      <li>Stacks & Queues – Parentheses, sliding window, monotonic stacks</li>
      <li>Trees & Binary Search Trees – Traversals, LCA, balanced search</li>
      <li>Heaps & Priority Queues – Top-K problems, merging lists</li>
      <li>Hash Tables / Maps – Counting, grouping, lookup</li>
      <li>Graphs – Adjacency lists, BFS/DFS, shortest path, cycles</li>
    </ul>
  </section>

  <section>
    <h2>2. Recursion & Backtracking</h2>
    <ul>
      <li>Fundamental recursion – Towers of Hanoi style reasoning</li>
      <li>Backtracking – Subsets, permutations, letter combinations</li>
      <li>When to use – Problems with branching where you try multiple choices</li>
    </ul>
  </section>

  <section>
    <h2>3. Greedy Algorithms</h2>
    <ul>
      <li>Concept – Always pick the most promising immediate option</li>
      <li>Classic applications – Interval scheduling, coin change (canonical), Huffman coding, MSTs</li>
      <li>Important tip – Must prove local choice leads to global optimal</li>
    </ul>
  </section>

  <section>
    <h2>4. Dynamic Programming (DP)</h2>
    <ul>
      <li>Foundational patterns: Fibonacci, 0/1 Knapsack, Rod cutting</li>
      <li>Common problems: LCS, Edit Distance, Stock Buy/Sell</li>
      <li>Key insight – DP = recursion + memoization</li>
    </ul>
  </section>

  <section>
    <h2>5. Binary Search & Two-Pointers</h2>
    <ul>
      <li>Binary search – Sorted arrays, rotated arrays, boundaries</li>
      <li>Two pointers – Sorted input, pairs/triplets, partitioning</li>
    </ul>
  </section>

  <section>
    <h2>6. Sorting & Searching</h2>
    <ul>
      <li>Sorting basics – Quick sort, merge sort, heap sort</li>
      <li>Applications – Custom sorting + two-pointer use cases</li>
    </ul>
  </section>

  <section>
    <h2>7. Graph Algorithms</h2>
    <ul>
      <li>BFS vs DFS, Topological sort, Union-Find</li>
      <li>Shortest paths – Dijkstra, Bellman-Ford</li>
      <li>Graph patterns – Islands, connectivity, shortest path</li>
    </ul>
  </section>

  <section>
    <h2>8. Advanced Topics</h2>
    <ul>
      <li>Tries – Word search, autocomplete</li>
      <li>Segment trees / Fenwick trees – Range queries</li>
      <li>Bitwise operations – XOR tricks, state compression</li>
      <li>Suffix arrays / automata – String matching</li>
    </ul>
  </section>

  <section>
    <h2>Suggested Preparation Flow</h2>
    <ol>
      <li>Master basic data structures (arrays, strings, trees)</li>
      <li>Practice recursion & backtracking</li>
      <li>Cover greedy problem types</li>
      <li>Practice binary search & two-pointer patterns</li>
      <li>Move into dynamic programming problems</li>
      <li>Learn fundamental graph algorithms</li>
    </ol>
  </section>

  <section>
    <h2>Strategy Tips</h2>
    <ul>
      <li>Drill problems across categories to build pattern recognition</li>
      <li>If multiple paths look viable → use recursion/DP</li>
      <li>If local decisions can be optimal globally → try greedy</li>
      <li>Sort + scan or binary search often gives better time complexity</li>
    </ul>
  </section>
</body>
</html>
